<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Danh sách hóa đơn</title>
  <style>
    body { font-family: Arial; padding: 20px; background: #f6f6f6; }
    h1 { margin-bottom: 15px; }
    table { width: 100%; border-collapse: collapse; background: white;}
    th, td { border: 1px solid #ddd; padding: 8px; font-size: 14px; }
    th { background: #f0f0f0; }
    .controls { margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; }
    input, button { padding: 6px 8px; }
    button { cursor: pointer; background: #1976d2; color: white; border: none; border-radius: 4px; }
  </style>
</head>

<body>
  <h1>Danh sách hóa đơn</h1>

  <!-- Filter controls -->
  <div class="controls">
    <label>Từ ngày <input type="date" id="from"></label>
    <label>Đến ngày <input type="date" id="to"></label>
    <button id="apply">Lọc</button>
    <button id="reset">Xóa</button>
  </div>

  <div id="status">Đang tải dữ liệu...</div>
  <div id="tableWrap"></div>

  <script>
    const DATA_URL = "https://script.google.com/macros/s/AKfycbwnoIs3T8FKrq53SG7lCTwE1Rm0H6eWc05mD1S347XscHkgg-VxMkHO96b_8Z-O_r0j/exec";
    let rawData = [];

    // -------------------------------
    // Parse date without timezone shifts:
    // trả về Date(year,monthIndex,day) hoặc null
    // -------------------------------
    function parseDateOnly(value) {
      if (!value && value !== 0) return null;

      // nếu đã là Date -> chỉ lấy phần ngày
      if (value instanceof Date) {
        if (isNaN(value)) return null;
        return new Date(value.getFullYear(), value.getMonth(), value.getDate());
      }

      // số (ms kể từ 1970)
      if (typeof value === 'number') {
        const d = new Date(value);
        if (isNaN(d)) return null;
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      }

      const s = String(value).trim();

      // yyyy-mm-dd (có thể kèm giờ: yyyy-mm-ddTHH:MM:SS... )
      let m = s.match(/(\d{4})-(\d{2})-(\d{2})/);
      if (m) {
        const y = Number(m[1]), mo = Number(m[2]) - 1, da = Number(m[3]);
        return new Date(y, mo, da);
      }

      // dd/mm/yyyy
      m = s.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
      if (m) {
        const da = Number(m[1]), mo = Number(m[2]) - 1, y = Number(m[3]);
        return new Date(y, mo, da);
      }

      // fallback: try Date parse, then extract local Y/M/D
      const d = new Date(s);
      if (!isNaN(d)) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      }

      return null;
    }

    // -------------------------------
    // Tải dữ liệu từ Apps Script
    // -------------------------------
    async function loadData() {
      try {
        const res = await fetch(DATA_URL);
        const data = await res.json();
        rawData = Array.isArray(data) ? data : (data.rows || []);
        document.getElementById("status").textContent = "Đã tải " + rawData.length + " bản ghi.";
        applyFiltersFromURL();
      } catch (err) {
        document.getElementById("status").textContent = "Lỗi tải dữ liệu: " + err;
      }
    }

    // -------------------------------
    // Hiển thị bảng (lấy các cột tự động)
    // -------------------------------
    function renderTable(list) {
      if (!list || list.length === 0) {
        document.getElementById("tableWrap").innerHTML = "<p>Không có dữ liệu.</p>";
        return;
      }

      const cols = Object.keys(list[0]);
      let html = "<table><thead><tr>" + cols.map(c => `<th>${c}</th>`).join('') + "</tr></thead><tbody>";

      for (const r of list) {
        html += "<tr>" + cols.map(c => {
          // nếu c là ngayXuatHoaDon -> format đẹp
          if (c.toLowerCase().includes('ngay') || c.toLowerCase().includes('ngayxuat') || c.toLowerCase().includes('ngay_xuat')) {
            return `<td>${formatDate(r[c])}</td>`;
          }
          // tiền -> format số (giả định tên cột chứa 'tien' hoặc 'soTien')
          if (c.toLowerCase().includes('tien') || c.toLowerCase().includes('sotien') || c.toLowerCase().includes('so_tien')) {
            const v = r[c]==null ? '' : Number(r[c]);
            return `<td style="text-align:right">${isNaN(v) ? (r[c] ?? '') : v.toLocaleString()}</td>`;
          }
          return `<td>${r[c] ?? ''}</td>`;
        }).join('') + "</tr>";
      }

      html += "</tbody></table>";
      document.getElementById("tableWrap").innerHTML = html;
    }

    // -------------------------------
    // Format ngày dùng parseDateOnly -> dd/mm/yyyy
    // -------------------------------
    function formatDate(raw) {
      const d = parseDateOnly(raw);
      if (!d) return '';
      const dd = String(d.getDate()).padStart(2, '0');
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    }

    // -------------------------------
    // Lọc dữ liệu: dùng parseDateOnly để so sánh ngày (không bị timezone)
    // -------------------------------
    function filterData({ fromDate = null, toDate = null } = {}) {
      // fromDate/toDate được đưa vào ở dạng Date chỉ phần ngày (hoặc null)
      return rawData.filter((r) => {
        const d = parseDateOnly(r.ngayXuatHoaDon ?? r['Ngày xuất'] ?? r['ngay_xuat'] ?? r['ngayXuatHoaDon']);
        if (!d) return false;

        if (fromDate && d < fromDate) return false;

        if (toDate) {
          if (d > toDate) return false; // both are date-only (00:00 local), so inclusive logic below
        }

        return true;
      });
    }

    // -------------------------------
    // Read URL params & apply filters
    // -------------------------------
    function applyFiltersFromURL() {
      const params = new URLSearchParams(location.search);
      const tungay = params.get("tungay");
      const denngay = params.get("denngay");

      const tryParseUrl = s => {
        if (!s) return null;
        // handle dd/mm/yyyy
        const m1 = String(s).match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        if (m1) return new Date(Number(m1[3]), Number(m1[2]) - 1, Number(m1[1]));
        // handle yyyy-mm-dd
        const m2 = String(s).match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (m2) return new Date(Number(m2[1]), Number(m2[2]) - 1, Number(m2[3]));
        // fallback to parseDateOnly
        return parseDateOnly(s);
      };

      const from = tryParseUrl(tungay);
      const to = tryParseUrl(denngay);

      // For inclusive 'to', we keep as date-only but comparison in filterData is <= since both are date-only
      if (from) document.getElementById("from").value = from.toISOString().slice(0, 10);
      if (to) document.getElementById("to").value = to.toISOString().slice(0, 10);

      const list = filterData({ fromDate: from, toDate: to });
      renderTable(list);
    }

    // -------------------------------
    // Buttons
    // -------------------------------
    document.getElementById("apply").onclick = () => {
      const vFrom = document.getElementById("from").value;
      const vTo = document.getElementById("to").value;

      const from = vFrom ? (()=>{
        const [y,m,d] = vFrom.split('-').map(Number);
        return new Date(y, m-1, d);
      })() : null;

      const to = vTo ? (()=>{
        const [y,m,d] = vTo.split('-').map(Number);
        return new Date(y, m-1, d);
      })() : null;

      const list = filterData({ fromDate: from, toDate: to });
      renderTable(list);

      // update URL without reload
      const p = new URLSearchParams(location.search);
      if (from) p.set('tungay', vFrom); else p.delete('tungay');
      if (to) p.set('denngay', vTo); else p.delete('denngay');
      history.replaceState(null, '', location.pathname + (p.toString() ? '?' + p.toString() : ''));
    };

    document.getElementById("reset").onclick = () => {
      document.getElementById("from").value = "";
      document.getElementById("to").value = "";
      renderTable(rawData);
      history.replaceState(null, '', location.pathname);
    };

    // Khởi động
    loadData();
  </script>
</body>
</html>
